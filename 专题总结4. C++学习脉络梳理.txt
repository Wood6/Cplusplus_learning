2 ~12 C++对C的升级：const、bool、参数默认值、函数重载->函数名****、C++四中强制类型转换、const引用
14~28 C++中的类
	14~16 类的表示法
	17~24 构造函数、拷贝构造函数、成员变量初始化顺序、对象构造顺序、析构函数
	25~26 静态成员变量、静态成员函数
	27    二阶构造
	28    友元
	
29~40 函数重载
	29    类的成员函数指针、函数重载的深度意义
	30~40 各个操作符重载示例、重载=实现深度拷贝、智能指针、重载逻辑操作符和逗号操作符的坑
	
41~42 避免隐式转换的危害、显示进行类的转换构造函数、类类型转换函数的替代

43~48 继承来了
	43~45  protected专为继承而生、继承方式public
	46     子类(只会)自动调用父类的默认/无参构造函数、继承关系的构造/析构顺序
	47     同名隐藏、隐藏发生时访问父类加域名符
	48     函数重写、赋值兼容
	
49~50 函数重写遇上赋值兼容性导致的问题引出多态、virtual函数
51    用C写面向对象，展现多态的本质、虚函数表
52    纯虚函数、接口类
53    单继承/多继承的多态内存模型、重复继承的2个问题（数据冗余、二义性）、单一虚继承解决问题
54    多继承问题及解决：同对象不同地址、安全类类型转换推荐dynamic_cast、多继承的正确打开方式：单继承+多接口
55    new/delete 和 malloc/free 的区别、构造/析构不发生任何多态行为、dynamic_cast使用要有虚函数表、对类对象重载 ->
56    变量交换：宏实现 --> 函数实现 --> 模板实现，从而引出模板
57    模板参数隐式转换需显示指定、模板函数有两次编译、（若有）返回值为模板参数的第一个、函数模板与普通函数重载时普通函数优先
58    引出类模板（同样两次编译）
59    类模板的部分特化和完全特化、函数模板只有完全特化
60    类模板特化最高效求1+2+3+...+N的值
61    STL标准库智能指针
62    static实现单例类
63    if-else C语言风格异常处理、进一步setjmp()和longjmp()但打破程序结构不推荐
64~65 C++语言语法上支持try-catch异常处理机制（自上而下严格匹配）、try-catch的工程应用
66    typeid关键字识别类型信息（类型静态识别、类型动态识别）
67    模板与变参函数识别指针变量、优化sizeof避开变参函数接受类对象时的运行期错误、构造函数抛出异常探讨
68    泛型编程旧式写法class，引出typename的由来、try-catch将函数体分成2部分-另类写法不推荐
69    mutable关键字专为打破const属性设计不要滥用、new/delete 和 new[]/delete[] 诸多探讨
70    未来展望
71-72 异常处理深入探讨：两个关键函数：terminate()、unexepected()
73    new的结果探讨及工程中人为统一规范处理还有new的带参用户示例  



