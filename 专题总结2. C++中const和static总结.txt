const在C/C++用法总结：

const 修饰局部变量时，C++ 以键值对的形式放入常量表中，遇到&等操作时，会在内存中分配一个变量，只读属性，用指针可改写！但常量区不会变！  
const 修饰全局变量时，C/C++ 都将其放与.data中的只读存储取，有地址，但都是不能改写，C/C++ 用指针也都不能改写！、
以上示例代码见 3_1

const 修饰引用时：见示例代码 5_1
const int& b = a; （只读变量b）
const int& b = 1; （只读变量b）
const int b = 1;  （常量b）

示例代码12_1
const type& 类型与其初始化变量类型相同=>只读变量，不同时=>新的变量；
volatile const type => 只读变量

const修饰类成员变量：示例代码 20_5、20_6
const成员，会分配空间。其存储空间与对象存储位置一样,可在栈上、堆或全局区等,但编译期间无法确定初始化，所以不会进入符号表
const 成员变量不能在构造函数中初始化,被const修饰，不能作为左值，只能在声明时或者初始化列表中初始化；
const 成员变量是个只读变量

const 修饰的类、const修饰的类成员函数时： 示例代码 24_2
const对象只能调用const成员函数
const成员函数只能调用const成员函数，也不能改变成员变量的值，但可以用指针间接改变
非const对象可以调用非const成员函数也可以调用const成员函数（优先严格匹配）

static 修饰类成员变量和类成员函数： 示例代码见 25_1 26_1 26_2
static修饰类成员变量存储区为全局存储区；
静态成员函数可以直接访问静态成员变量，访问普通成员变量必须通过该对象引用或该对象指针（因为没有this指针）；普通成员函数可以直接访问普通成员变量和静态成员变量；
静态成员函数可以通过类名直接调用；普通成员函数必须通过对象名调用；private对静态成员函数同样有效

示例代码29_2
全局函数与静态成员函数不构成重载（因为作用域不同）
类中普通成员与静态成员构成重载关系（作用域相同，且符合重载条件）

示例代码 60_1
static const type 类中的成员变量，此时这个是个常量





